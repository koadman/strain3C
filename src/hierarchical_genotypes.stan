data {
    int B; // the number of haplotype blocks
    int block_size[B]; // the number of sites in each block
    int block_haplotypes[B]; // the number of haplotypes in each block
    int H; // maximum number of haplotypes in a block
    int max_sites_per_block;
    real<lower=0,upper=1> block_genotype[B,H,max_sites_per_block];
    real<lower=0,upper=1> block_abundance[B,H];

    int L_hic; // number of links among sites (edges in graph)
    int hic_linkcounts[L_hic,4]; // counts of SNV co-observation. Genotypes are binary variables: mutant or not. Four possible combinations among two sites: 00,01,10,11
    int hic_linksites[L_hic,4]; // the indices of the two sites involved in each link. Each index is composed of a block/contig ID and a site ID within that block

    int K; // number of components to factorize
    real<lower=0> abundance_prior;
    real subsample;
}

transformed data {
  vector[H] babund_vector[B];
  for(b in 1:B){
    for(h in 1:H){
      babund_vector[b][h] = block_abundance[b,h];
    }
  }
}

parameters {
    simplex[H] genotype[K,B]; // The assignment of block haplotypes to strains
    simplex[K] abundance;  // the abundance of each strain
}

model {
    for(k in 1:K){
      for(h in 1:H){
        // TODO: genotype should be a collection of "one hot" vectors per strain per block
        // is there a more sensible prior for this?
        genotype[k,h] ~ beta(0.1,0.1);
      }
    }
    abundance ~ exponential(abundance_prior);

    for( i in 1:L_hic ){
        vector[4] theta;
        int block_1;
        int block_2;
        int site_1;
        int site_2;
        block_1 = hic_linksites[i,1];
        site_1 = hic_linksites[i,2];
        block_2 = hic_linksites[i,3];
        site_2 = hic_linksites[i,4];
        theta = rep_vector(0,4);
        for( k in 1:K ){
          vector[4] theta_k;
          theta_k = rep_vector(0,4);
            for( h1 in 1:block_haplotypes[block_1]){
              for( h2 in 1:block_haplotypes[block_2]){
                vector[4] t_k;
                real genotype_1;
                real genotype_2;
                genotype_1 = block_genotype[k,block_1,site_1];
                genotype_2 = block_genotype[k,block_2,site_2];
                // probability that the haplotype blocks generate each genotype
                t_k[1] = (1-genotype_1) * (1-genotype_2);
                t_k[2] = (1-genotype_1) * genotype_2;
                t_k[3] = genotype_1 * (1-genotype_2);
                t_k[4] = genotype_1 * genotype_2;
                // probability that strain k is generated by these haplotype blocks
                theta_k += genotype[k,block_1,h1] * genotype[k,block_2,h2] * t_k;
              }
            }
            // abundance of strain k
            theta += abundance[k] * theta_k;
        }
        target += multinomial_lpmf(hic_linkcounts[i] | theta / sum(theta));
    }
    // probability of haplotype abundances
    for( b in 1:B) {
      vector[H] b_abund;
      b_abund = rep_vector(0,H);
      for( k in 1:K ){
        b_abund += abundance[k] * genotype[k,b];
      }
      target += dirichlet_lpdf(babund_vector[b] | b_abund);
    }
}

generated quantities {
	vector[L_hic] log_lik;
}
